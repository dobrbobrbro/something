#include "stdafx.h"
#include "ContentBrowser.h"
#include "..//UI/MyFonts.h"
#include "../Editors/xrEProps/Tree/Choose/UIChooseForm.h"
#include "../Editors/xrECore/Editor/Library.h"
#include "../Editors/LevelEditor/UI/Tools/UIObjectTool.h"
#include "../xrCore/FS.h"
#include <algorithm>
#include <windows.h>
#include <commdlg.h>
#include <cctype>
#include <iterator>
#include <thread>
#include <mutex>
#include <queue>
#include <shellapi.h>
#include "..\xrEUI\imgui.h"
#include "../Editors/LevelEditor/UI/UIEditLibrary.h"
#include "..//UI/MyStyle.h"
#include "../Editors/xrEUI/imgui_impl_dx9.h"
#include "..//Editors/xrECore/Engine/Texture.h"
#include "..\..\xrRender\Private\SH_Texture.h"



std::queue<xr_string> thumbnailLoadQueue;
std::mutex thumbnailMutex;
bool thumbnailThreadRunning = false;




xr_string UIContentBrowser::NormalizeName(xr_string s) {
    while (!s.empty() && (s[0] == '\\' || s[0] == '/')) s.erase(0, 1);
    std::replace(s.begin(), s.end(), '/', '\\');
    return s;
}

bool UIContentBrowser::IsValidName(const xr_string& name) {
    if (name.empty() || name.find_first_of("@#,`") != xr_string::npos)
        return false;
    for (char c : name)
        if (!std::isalnum(c) && c != '_' && c != '\\' && c != '.')
            return false;
    return true;
}

bool UIContentBrowser::ResolveObjectFile(const xr_string& candidate, xr_string& outFullPath) {
    xr_string name = NormalizeName(candidate);
    if (!IsValidName(name)) {
        ELog.Msg(mtError, "ResolveObjectFile: Invalid name: %s", name.c_str());
        return false;
    }
    string_path tmp;
    if (FS.exist(tmp, "$objects$", name.c_str())) {
        outFullPath = name;
        ELog.Msg(mtInformation, "ResolveObjectFile: Found file: %s in $objects$", name.c_str());
        return true;
    }
    auto has_dot = name.find_last_of('.');
    xr_string base = (has_dot == xr_string::npos) ? name : name.substr(0, has_dot);
    xr_string rel = base + ".object";
    if (FS.exist(tmp, "$objects$", rel.c_str())) {
        outFullPath = rel;
        ELog.Msg(mtInformation, "ResolveObjectFile: Found file: %s in $objects$", rel.c_str());
        return true;
    }
    rel = base + ".lwo";
    if (FS.exist(tmp, "$objects$", rel.c_str())) {
        outFullPath = rel;
        ELog.Msg(mtInformation, "ResolveObjectFile: Found file: %s in $objects$", rel.c_str());
        return true;
    }
    ELog.Msg(mtError, "ResolveObjectFile: File not found: %s in $objects$", name.c_str());
    return false;
}

UIContentBrowser* UIContentBrowser::Instance() {
    static UIContentBrowser instance;
    return &instance;
}
//
UIContentBrowser::UIContentBrowser()
{
    m_CurrentPath.clear();
    m_RefreshInProgress = false;
    m_Selection = false;
    m_SelectedItem.clear();
    m_SearchQuery.clear();
    m_PendingObject.clear();
    m_AddButtonClicked = false;
    m_RenameDialogOpen = false;
    m_DeleteDialogOpen = false;
    m_NewNameBuffer[0] = '\0';
    m_ObjectList = xr_new<UIItemListForm>();
  
   

    //----------------------------//
    m_tFavorite.create("ed\\bar\\rollic\\contentbrowser\\favoriteno.dds");
    m_tFavorite->Load();

    m_tSketchfab.create("ed\\bar\\rollic\\contentbrowser\\Sketchfab.dds");
    m_tSketchfab->Load();
    m_tFab.create("ed\\bar\\rollic\\contentbrowser\\Fab.dds");
    m_tFab->Load();
    m_TextureNull.create("\\ed\\bar\\rollic\\contentbrowser\\StaticMeshActor_64");
    m_TextureNull->Load();
    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\folder.dds"))
        m_tFolder.create("ed\\bar\\rollic\\contentbrowser\\folder");
    else
        m_tFolder.create("$game_textures$\\ed\\folder");
    m_tFolder->Load();

    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\folder-closed.dds"))
        m_tFolderClosed.create("ed\\bar\\rollic\\contentbrowser\\folder-closed");
    else
        m_tFolderClosed.create("$game_textures$\\ed\\folder");
    m_tFolderClosed->Load();

    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\folder-open.dds"))
        m_tFolderOpen.create("ed\\bar\\rollic\\contentbrowser\\folder-open");
    else
        m_tFolderOpen.create("$game_textures$\\ed\\folder");
    m_tFolderOpen->Load();

    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\up.dds"))
        m_tUp.create("ed\\bar\\rollic\\contentbrowser\\up");
    else
        m_tUp.create("$game_textures$\\ed\\ed_nodata");
    m_tUp->Load();
    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\down.dds"))
        m_tDown.create("ed\\bar\\rollic\\contentbrowser\\down");
    else
        m_tDown.create("$game_textures$\\ed\\ed_nodata");
    m_tDown->Load();
    m_tAdd.create("ed\\bar\\rollic\\contentbrowser\\add");
    m_tAdd->Load();
    m_tRefresh.create("ed\\bar\\rollic\\contentbrowser\\refresh");
    m_tRefresh->Load();
    m_tRename.create("ed\\bar\\rollic\\contentbrowser\\rename");
    m_tRename->Load();
    if (FS.exist("$game_textures$", "ed\\bar\\rollic\\contentbrowser\\delete.dds"))
        m_tDelete.create("ed\\bar\\rollic\\contentbrowser\\delete");
    else
        m_tDelete.create("$game_textures$\\ed\\ed_nodata");
    m_tDelete->Load();
    m_tTrashFolder.create("ed\\bar\\rollic\\contentbrowser\\trash_folder");
    m_tTrashFolder->Load();



    RefreshList();






}

UIContentBrowser::~UIContentBrowser()
{
    for (auto& pair : m_PreviewCache)
        if (pair.second.textureID && pair.second.textureID != m_TextureNull->surface_get()) {}
    m_PreviewCache.clear();
    m_TextureNull.destroy();
    m_tFolder.destroy();
    m_tFolderClosed.destroy();
    m_tFolderOpen.destroy();
    m_tUp.destroy();
    m_tDown.destroy();
    m_tAdd.destroy();
    m_tRefresh.destroy();
    m_tRename.destroy();
    m_tDelete.destroy();
    m_tTrashFolder.destroy();
    m_tFavorite.destroy();
    m_tSketchfab.destroy();
    m_tFab.destroy();
    xr_delete(m_ObjectList);
}

void UIContentBrowser::BuildDirectoryTree() {
    m_DirectoryTree.children.clear();
    m_DirectoryTree.name.clear();
    m_DirectoryTree.isFolder = true;
    m_DirectoryTree.fullPath.clear();
    m_DirectoryTree.texture = m_tFolder->surface_get();

    FS_FileSet lst;
    if (Lib.GetObjects(lst)) {
        xr_string searchLower = m_SearchQuery;
        std::transform(searchLower.begin(), searchLower.end(), searchLower.begin(), [](char c) { return std::tolower(c); });

        for (const auto& file : lst) {
            xr_string relativeName = file.name;
            if (!IsValidName(relativeName))
                continue;

            xr_string relativeLower = relativeName;
            std::transform(relativeLower.begin(), relativeLower.end(), relativeLower.begin(), [](char c) { return std::tolower(c); });
            if (!m_SearchQuery.empty() && relativeLower.find(searchLower) == xr_string::npos)
                continue;

            std::vector<xr_string> parts;
            size_t pos = 0;
            while ((pos = relativeName.find('\\')) != xr_string::npos) {
                parts.push_back(relativeName.substr(0, pos));
                relativeName.erase(0, pos + 1);
            }
            parts.push_back(relativeName);

            DirectoryNode* current = &m_DirectoryTree;
            xr_string currentPath;
            for (size_t i = 0; i < parts.size(); ++i) {
                const auto& part = parts[i];
                if (!currentPath.empty()) currentPath += "\\";
                currentPath += part;

                if (i < parts.size() - 1) {
                    auto it = std::find_if(current->children.begin(), current->children.end(),
                        [&part](const DirectoryNode& node) { return node.name == part && node.isFolder; });
                    if (it == current->children.end()) {
                        DirectoryNode folder;
                        folder.name = part;
                        folder.isFolder = true;
                        folder.fullPath = currentPath;
                        folder.texture = (currentPath == "_trash") ? m_tTrashFolder->surface_get() : m_tFolder->surface_get();
                        current->children.push_back(folder);
                        current = &current->children.back();
                    }
                    else {
                        current = &*it;
                    }
                }
                else {
                    bool isFolder = relativeName.find('\\') != xr_string::npos;
                    auto it = std::find_if(current->children.begin(), current->children.end(),
                        [&part, isFolder](const DirectoryNode& node) { return node.name == part && node.isFolder == isFolder; });
                    if (it == current->children.end()) {
                        DirectoryNode node;
                        node.name = part;
                        node.isFolder = isFolder;
                        node.fullPath = currentPath;
                        node.texture = isFolder ? ((currentPath == "_trash") ? m_tTrashFolder->surface_get() : m_tFolder->surface_get()) : m_TextureNull->surface_get();
                        current->children.push_back(node);
                    }
                }
            }
        }
    }

    auto sortChildren = [](xr_vector<DirectoryNode, xalloc<DirectoryNode>>& children) {
        std::sort(children.begin(), children.end(),
            [](const DirectoryNode& a, const DirectoryNode& b) {
                return a.isFolder == b.isFolder ? a.name < b.name : a.isFolder > b.isFolder;
            });
    };
    std::function<void(DirectoryNode&)> sortRecursive = [&](DirectoryNode& node) {
        sortChildren(node.children);
        for (auto& child : node.children) {
            if (child.isFolder) sortRecursive(child);
        }
    };
    sortChildren(m_DirectoryTree.children);
    for (auto& child : m_DirectoryTree.children) {
        if (child.isFolder) sortRecursive(child);
    }
}

void UIContentBrowser::DrawItem(const DirectoryNode& node, const xr_string& parentPath, float indentLevel) {
    ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;
    if (!node.isFolder) {
        flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
    }
    if (m_SelectedItem == node.name) {
        flags |= ImGuiTreeNodeFlags_Selected;
    }
    if (node.isFolder && !m_SearchQuery.empty()) {
        flags |= ImGuiTreeNodeFlags_DefaultOpen;
    }

    xr_string itemPath = parentPath.empty() ? node.name : parentPath + "\\" + node.name;
    bool isOpen = false;

    if (node.isFolder) {
        ImGui::Image(node.fullPath == m_CurrentPath ? m_tFolderOpen->surface_get() : node.texture, ImVec2(16, 16));
        ImGui::SameLine();
        isOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);
    }
    else {
        auto it = m_PreviewCache.find(node.name);
        ImTextureID imgID = (it != m_PreviewCache.end()) ? it->second.textureID : m_TextureNull->surface_get();
        ImGui::Image(imgID, ImVec2(16, 16));
        ImGui::SameLine();
        ImGui::TreeNodeEx(node.name.c_str(), flags);
    }

    if (ImGui::IsItemClicked()) {
        OnItemClicked(node.name, node.isFolder, itemPath);
    }

    if (isOpen) {
        for (const auto& child : node.children) {
            DrawItem(child, itemPath, indentLevel + ImGui::GetTreeNodeToLabelSpacing());
        }
        ImGui::TreePop();
    }
}


void UIContentBrowser::Draw()
{
    static bool showWindow = true;
    static float tileSize = 100.0f; // Default tile size
    static xr_string contextMenuItem; // Store item for context menu


    if (ImGui::IsKeyDown(ImGuiKey_LeftCtrl) && ImGui::IsKeyPressed(ImGuiKey_Space, false)) {
        showWindow = !showWindow;
    }

    if (!showWindow) {
        return;
    }

    ImGui::Begin("Content Browser", &showWindow, ImGuiWindowFlags_None);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 10.0f);
    ImGui::Columns(2, nullptr, true);
    ImGui::SetColumnWidth(0, 230.0f);

    {
        ImGui::BeginChild("Object List", ImVec2(0, 0), true, ImGuiWindowFlags_NoScrollbar);
        ImGui::BeginGroup();
        float search_width = 208.0f;
        ImGui::SetNextItemWidth(search_width);
        char buffer[256];
        xr_strcpy(buffer, m_SearchQuery.c_str());
        if (ImGui::InputTextWithHint("##Search", "Search", buffer, sizeof(buffer))) {
            m_SearchQuery = buffer;
            RefreshList();
        }
        ImGui::EndGroup();
        ImGui::Separator();
        ImGui::BeginChild("ScrollableList", ImVec2(0, 0), false);
        ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(245, 175, 37, 255)); //#f5af25
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(131, 215, 255, 255)); //#83d7ff
        for (const auto& node : m_DirectoryTree.children) {
            if (node.isFolder) {
                DrawItem(node, "", 0.0f);
            }
            else {
                ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
                if (m_SelectedItem == node.name) {
                    flags |= ImGuiTreeNodeFlags_Selected;
                }
                ImGui::PushID(node.name.c_str());
                ImGui::Indent(0.0f);
                ImGui::BeginGroup();
                ImGui::Image(node.texture, ImVec2(20, 20));
                ImGui::SameLine(0.0f, 4.0f);
                bool isOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);
                if (ImGui::IsItemClicked()) {
                    OnItemClicked(node.name, false, "");
                }
                ImGui::EndGroup();
                ImGui::Unindent(0.0f);
                ImGui::PopID();
            }
        }
        ImGui::PopStyleColor(2);
        ImGui::EndChild();
        ImGui::Separator();
        ImGui::EndGroup();
        ImGui::EndChild();

        RStringVec selectedItems;
        if (m_ObjectList->GetSelected(selectedItems) && !selectedItems.empty()) {
            xr_string sel = selectedItems[0].c_str();
            if (m_SelectedItem != sel && IsValidName(sel)) {
                m_SelectedItem = sel;
                ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
                if (objTool && objTool->pForm) {
                    UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm);
                    if (uiObjTool) {
                        xr_string fullPath = m_CurrentPath;
                        if (!fullPath.empty()) fullPath += "\\";
                        fullPath += m_SelectedItem;
                        uiObjTool->SetCurrent(fullPath.c_str());
                        m_PendingObject = fullPath;
                    }
                }
            }
            else if (!IsValidName(sel)) {
                m_SelectedItem.clear();
                m_PendingObject.clear();
            }
        }
    }

    ImGui::NextColumn();
    ImGui::BeginGroup();
    if (ImGui::ImageButton(m_tUp->surface_get(), ImVec2(20, 20)) && !m_CurrentPath.empty())
    {
        size_t pos = m_CurrentPath.find_last_of('\\', m_CurrentPath.length() - 2);
        m_PathHistory.push_back(m_CurrentPath);
        m_CurrentPath = pos != xr_string::npos ? m_CurrentPath.substr(0, pos) : "";
        m_PreviewCache.clear();
        m_CacheOrder.clear();
        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
     if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

    ImGui::SameLine(0.0f, 4.0f);
    if (ImGui::ImageButton(m_tDown->surface_get(), ImVec2(20, 20)) && !m_PathHistory.empty())
    {
        m_CurrentPath = m_PathHistory.back();
        m_PathHistory.pop_back();
        m_PreviewCache.clear();
        m_CacheOrder.clear();
        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    //------------------------------------------//
    //                  ПУТЬ                    //
    //------------------------------------------//

    ImGui::SameLine(0.0f, 4.0f);
    ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.059f, 0.059f, 0.059f, 1.0f)); // #0f0f0f
    ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.19f, 0.19f, 0.19f, 1.0f)); // #303030
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.3020f, 0.3020f, 0.3020f, 1.0f)); // #f5af25 цвет текста пути 
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
    ImGui::BeginChild("PathDisplay", ImVec2(0 - 84.0f, ImGui::GetTextLineHeightWithSpacing() + 2.0f), true);
    ImGui::Text("Path: %s", m_CurrentPath.c_str());
    ImGui::EndChild();
    ImGui::PopStyleVar();
    ImGui::PopStyleColor(3);
    ImGui::EndGroup();
    //------------------------------------------//
    //          НА СКЕТЧФАБ - КНОПКА            //
    //------------------------------------------//

    ImGui::SameLine();
    if (ImGui::ImageButton(m_tSketchfab->surface_get(), ImVec2(20, 20)))
    {
        ShellExecuteA(0, "open", "https://sketchfab.com/", NULL, NULL, SW_SHOWNORMAL);
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    DrawGlowingOutline("#00B8D4"); // Голубой цвет
    ImGui::SameLine();
    if (ImGui::ImageButton(m_tFab->surface_get(), ImVec2(20, 20)))
    {
        ShellExecuteA(0, "open", "https://www.fab.com/channels/unreal-engine?listing_types=3d-model", NULL, NULL, SW_SHOWNORMAL);
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    DrawGlowingOutline("#00B8D4"); // Голубой цвет
    //==========================================//
   

    //------------------------------------------//
    //             КНОПКИ НА ПАНЕЛЕ             //
    //------------------------------------------//
    //---- STYLE of BUTTONS ----//
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.18f, 0.18f, 0.18f, 1.0f)); // #2e2e2e
    ImGui::PushStyleColor(ImGuiCol_Border, ImVec4(0.09f, 0.09f, 0.09f, 1.0f)); // #171717
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.22f, 0.22f, 0.22f, 1.0f)); // #383838
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 5.0f);
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4, 2));
    
   

    //---- REFRESH BUTTON ----//

    if (ImGui::Button("##RefreshButton", ImVec2(80, 20)))
    {
        m_PreviewCache.clear();
        m_CacheOrder.clear();
        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImVec2 refresh_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tRefresh->surface_get(),
        ImVec2(refresh_pos.x + 4, refresh_pos.y + 2),
        ImVec2(refresh_pos.x + 20, refresh_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(refresh_pos.x + 24, refresh_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Refresh");
    DrawGlowingOutline("#00B8D4");
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImGui::SameLine();

    //---- IMPORT BUTTON ----//

    if (ImGui::Button("##ImportButton", ImVec2(80, 20)))
    {
        OPENFILENAME ofn;
        char szFile[260 * 16] = { 0 };
        ZeroMemory(&ofn, sizeof(OPENFILENAME));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = NULL;
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = sizeof(szFile);
        ofn.lpstrFilter = "All Files\0*.*\0Object Files\0*.ogf;*.object\0";
        ofn.nFilterIndex = 1;
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT | OFN_EXPLORER;
        if (GetOpenFileName(&ofn))
        {
            xr_string destDir = NormalizeName(m_CurrentPath);
            if (!destDir.empty()) destDir += "\\";
            xr_string baseDestPath = FS.get_path("$objects$")->m_Path + destDir;
            CreateDirectoryA(baseDestPath.c_str(), NULL);
            ELog.Msg(mtInformation, "Import: Creating directory %s", baseDestPath.c_str());

            char* fileName = szFile;
            xr_string sourcePath = fileName;
            fileName += sourcePath.length() + 1;
            if (*fileName == '\0')
            {
                size_t lastSlash = sourcePath.find_last_of('\\');
                xr_string fileOnly = (lastSlash != xr_string::npos) ? sourcePath.substr(lastSlash + 1) : sourcePath;
                xr_string destPath = destDir + fileOnly;
                xr_string fullDestPath = FS.get_path("$objects$")->m_Path + destPath;
                ELog.Msg(mtInformation, "Import: Copying single file %s to %s", sourcePath.c_str(), fullDestPath.c_str());
                if (CopyFileA(sourcePath.c_str(), fullDestPath.c_str(), FALSE)) {
                    ELog.Msg(mtInformation, "Import: Successfully copied %s", fullDestPath.c_str());
                    RefreshList();
                }
                else {
                    DWORD error = GetLastError();
                    ELog.DlgMsg(mtError, "Import: Failed to copy %s to %s (Error code: %lu)", sourcePath.c_str(), fullDestPath.c_str(), error);
                }
            }
            else
            {
                while (*fileName != '\0')
                {
                    xr_string fileOnly = fileName;
                    xr_string fullSourcePath = sourcePath + "\\" + fileOnly;
                    xr_string destPath = destDir + fileOnly;
                    xr_string fullDestPath = FS.get_path("$objects$")->m_Path + destPath;
                    ELog.Msg(mtInformation, "Import: Copying multiple file %s to %s", fullSourcePath.c_str(), fullDestPath.c_str());
                    if (CopyFileA(fullSourcePath.c_str(), fullDestPath.c_str(), FALSE)) {
                        ELog.Msg(mtInformation, "Import: Successfully copied %s", fullDestPath.c_str());
                        RefreshList();
                    }
                    else {
                        DWORD error = GetLastError();
                        ELog.DlgMsg(mtError, "Import: Failed to copy %s to %s (Error code: %lu)", fullSourcePath.c_str(), fullDestPath.c_str(), error);
                    }
                    fileName += fileOnly.length() + 1;
                }
            }
        }
    }
    DrawGlowingOutline("#3bf028");
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

    ImVec2 import_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tAdd->surface_get(),
         ImVec2(import_pos.x + 4, import_pos.y + 2),
         ImVec2(import_pos.x + 20, import_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(import_pos.x + 24, import_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Import");
    DrawGlowingOutline("#3bf028");
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

    ImGui::SameLine();

    //---- RENAME BUTTON ----//

    if (ImGui::Button("##RenameButton", ImVec2(80, 20)) && !m_SelectedItem.empty())
    {
        m_RenameDialogOpen = true;
        xr_strcpy(m_NewNameBuffer, m_SelectedItem.c_str());
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImVec2 rename_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tRename->surface_get(),
        ImVec2(rename_pos.x + 4, rename_pos.y + 2),
        ImVec2(rename_pos.x + 20, rename_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(rename_pos.x + 24, rename_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Rename");
    DrawGlowingOutline("#00B8D4");
    ImGui::SameLine();

    //---- DELETE BUTTON ----//

    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.624f, 0.216f, 0.216f, 1.0f)); // #9f3737
    if (ImGui::Button("##DeleteButton", ImVec2(80, 20)) && !m_SelectedItem.empty())
    {
        m_DeleteDialogOpen = true;
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImGui::PopStyleColor();
    ImVec2 delete_pos = ImGui::GetItemRectMin();
    ImGui::GetWindowDrawList()->AddImage(m_tDelete->surface_get(),
        ImVec2(delete_pos.x + 4, delete_pos.y + 2),
        ImVec2(delete_pos.x + 20, delete_pos.y + 18));
    ImGui::GetWindowDrawList()->AddText(
        ImVec2(delete_pos.x + 24, delete_pos.y + 2),
        ImGui::GetColorU32(ImGuiCol_Text), "Delete");
    DrawGlowingOutline("#fd5386");
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    ImGui::SameLine();

    //---- RAWDATA BUTTON ----//

    if (ImGui::Button("Rawdata", ImVec2(80, 20)))
    {
        ClickOpenRawData();
    }
    if (ImGui::IsItemHovered())
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
    DrawGlowingOutline("#00B8D4");
    //---- STYLE CLOSING -----//
    ImGui::PopStyleVar(2);
    ImGui::PopStyleColor(3);
    //------------------------//

    //------------------------------------------//
    //         CЛАЙДЕР РАЗМЕРА ПЛИТОК           //
    //------------------------------------------//
    ImGui::SameLine(0.0f, 4.0f);
    ImGui::SetNextItemWidth(120.0f);
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 7.0f); //Скругление 7.0f
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4.0f, (20.0f - ImGui::GetTextLineHeight()) / 2)); //Высота 
    ImGui::SliderFloat("##TileSize", &tileSize, 32.0f, 256.0f, "Tile Size: %.0f");
    ImGui::PopStyleVar(2); // Убрать стиль после слайдера

    if (m_RenameDialogOpen)
    {
        ImGui::OpenPopup("Rename Item");
        ImGui::SetNextWindowSize(ImVec2(300, 120));
        if (ImGui::BeginPopupModal("Rename Item", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("Enter new name for '%s':", m_SelectedItem.c_str());
            ImGui::Separator();
            ImGui::InputText("##NewName", m_NewNameBuffer, sizeof(m_NewNameBuffer));
            ImGui::Separator();
            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                xr_string newName = m_NewNameBuffer;
                if (IsValidName(newName) && !newName.empty() && newName != m_SelectedItem)
                {
                    RenameItem(newName);
                }
                m_RenameDialogOpen = false;
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0)))
            {
                m_RenameDialogOpen = false;
            }
            ImGui::EndPopup();
        }
    }

    if (m_DeleteDialogOpen)
    {
        ImGui::OpenPopup("Delete Item");
        ImGui::SetNextWindowSize(ImVec2(300, 120));
        if (ImGui::BeginPopupModal("Delete Item", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("Are you sure you want to delete '%s'?", m_SelectedItem.c_str());
            ImGui::Separator();
            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                DeleteItem();
                m_DeleteDialogOpen = false;
            }
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0)))
            {
                m_DeleteDialogOpen = false;
            }
            ImGui::EndPopup();
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    ImGui::BeginChild("Content", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar);
    const float spacing = 3.0f; // Горизонтальный отступ 3px
    float availableWidth = ImGui::GetContentRegionAvail().x - 15.0f; // Учитываем сдвиг сетки на 15px
    int columns = std::max(1, (int)(availableWidth / (tileSize + spacing + 5.0f))); // Учитываем внутренний отступ 5px
    float columnWidth = (availableWidth - (columns - 1) * spacing - columns * 5.0f) / columns; // Учитываем все отступы


    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, 5.0f)); // Горизонтальный 3px, вертикальный 5px
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 15.0f); // Сдвиг сетки на 15px вправо
    if (ImGui::BeginTable("ContentTable", columns, ImGuiTableFlags_SizingFixedFit))
    {
        for (int i = 0; i < columns; i++) {
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed, columnWidth);
        }

        int columnIndex = 0; // Отслеживаем текущую колонку
        for (auto& item : m_Items)
        {
            if (columnIndex == 0) {
                ImGui::TableNextRow();
                ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5.0f); // Фиксированный вертикальный отступ 5px
            }

            ImGui::TableNextColumn();
            ImGui::BeginGroup();
            ImGui::PushID(item.name.c_str());
            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.0f);
            bool isSelected = (m_SelectedItem == item.name);

            ImVec2 selectableSize(columnWidth - 4, tileSize + ImGui::GetTextLineHeightWithSpacing() + 10.0f); // Фиксированная высота
            ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.0f, 0.0f, 0.0f, 0.0f)); // #83D7FF для переопределения Header
            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.0f, 0.0f, 0.0f, 0.0f)); // #83D7FF ховер HeaderHovered
            ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.51f, 0.84f, 1.0f, 0.2f)); // #83D7FF рамка при клике HeaderActive
            if (ImGui::Selectable("##selectable", isSelected, ImGuiSelectableFlags_AllowDoubleClick, selectableSize))
            {
                if (IsValidName(item.name)) {
                    m_SelectedItem = item.name;
                    m_ObjectList->SelectItem(item.name.c_str());
                    if (ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT)))
                        if (objTool->pForm)
                            if (UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm)) {
                                xr_string fullPath = m_CurrentPath;
                                if (!fullPath.empty()) fullPath += "\\";
                                fullPath += m_SelectedItem;
                                uiObjTool->SetCurrent(fullPath.c_str());
                                m_PendingObject = fullPath;
                            }
                    if (ImGui::IsMouseDoubleClicked(0) && item.isFolder) {
                        m_PathHistory.push_back(m_CurrentPath);
                        xr_string fullPath = m_CurrentPath;
                        if (!fullPath.empty()) fullPath += "\\";
                        fullPath += item.name;
                        OnItemClicked(item.name, item.isFolder, fullPath);
                    }
                }
            }
            ImGui::PopStyleColor(3); // Снять стили Header

//------------------------------------------//
//            ОКНО ПОПАПА ПО ПКМ            //
//------------------------------------------//
            // --- Статические переменные для редактирования имени ---
            static bool renaming = false;
            static char renameBuffer[128] = "";

            Item* contextMenuTarget = nullptr;
            if (ImGui::BeginPopupContextItem("ItemContextMenu")) {
                if (contextMenuTarget != &item) {
                    contextMenuTarget = &item;
                    contextMenuItem = item.name;
                    strncpy(renameBuffer, item.name.c_str(), sizeof(renameBuffer) - 1);
                    renameBuffer[sizeof(renameBuffer) - 1] = '\0';
                }
                ImGui::SetWindowSize(ImVec2(310, 256));


                // --- ПРЕВЬЮ ---
                ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.117f, 0.117f, 0.117f, 1.0f));
                ImGui::BeginChild("ContextPreview", ImVec2(310, 178), false);

                ImTextureID previewID = m_TextureNull->surface_get();
                float originalImageWidth = 910.0f; // Размеры по умолчанию
                float originalImageHeight = 910.0f;

                // ШАГ 1: Попытка загрузить стандартное превью из кэша
                auto standardIt = m_PreviewCache.find(item.name);
                if (standardIt != m_PreviewCache.end()) {
                    previewID = standardIt->second.textureID;
                    originalImageWidth = standardIt->second.width;
                    originalImageHeight = standardIt->second.height;
                }

                // ШАГ 2: Проверяем наличие широкого превью
                xr_string wideTextureName = item.name;
                size_t dotPos = wideTextureName.find_last_of('.');
                if (dotPos != xr_string::npos)
                    wideTextureName = wideTextureName.substr(0, dotPos);
                wideTextureName += "_wide";

                // Проверяем, есть ли широкое превью в кэше. Если есть, используем его.
                auto wideIt = m_PreviewCache.find(wideTextureName);
                if (wideIt != m_PreviewCache.end()) {
                    previewID = wideIt->second.textureID;
                    originalImageWidth = wideIt->second.width;
                    originalImageHeight = wideIt->second.height;
                }
                else {
                    // Если широкого превью нет в кэше, пробуем его загрузить
                    string_path physicalPath;
                    xr_string widePreviewPath = "previews\\" + (m_CurrentPath.empty() ? "" : m_CurrentPath + "\\") + wideTextureName + ".png";
                    if (FS.exist(physicalPath, "$objects$", widePreviewPath.c_str()))
                    {
                        D3DXIMAGE_INFO imageInfo;
                        if (SUCCEEDED(D3DXGetImageInfoFromFileA(physicalPath, &imageInfo)))
                        {
                            IDirect3DTexture9* pTex = nullptr;
                            HRESULT hr = D3DXCreateTextureFromFileExA(
                                HW.pDevice,
                                physicalPath,
                                imageInfo.Width,
                                imageInfo.Height,
                                1,
                                0,
                                D3DFMT_A8R8G8B8,
                                D3DPOOL_MANAGED,
                                D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER,
                                D3DX_FILTER_BOX,
                                0,
                                nullptr,
                                nullptr,
                                &pTex
                            );
                            if (SUCCEEDED(hr) && pTex)
                            {
                                previewID = (ImTextureID)pTex;
                                originalImageWidth = (float)imageInfo.Width;
                                originalImageHeight = (float)imageInfo.Height;
                                pTex->AddRef();
                                ELog.Msg(mtInformation, "LoadThumbnail: Loaded wide preview PNG: %s", physicalPath);

                                // Сохраняем в кэш
                                CachedTexture newCacheEntry;
                                newCacheEntry.textureID = previewID;
                                newCacheEntry.width = originalImageWidth;
                                newCacheEntry.height = originalImageHeight;
                                m_PreviewCache[wideTextureName] = newCacheEntry;
                            }
                        }
                    }
                }

                // Масштабирование и отображение
                float maxWidth = 300.0f;
                float maxHeight = 168.0f;
                ImVec2 imageSize;

                if (originalImageWidth > maxWidth || originalImageHeight > maxHeight) {
                    float scaleX = maxWidth / originalImageWidth;
                    float scaleY = maxHeight / originalImageHeight;
                    float scale = std::min(scaleX, scaleY);
                    imageSize.x = originalImageWidth * scale;
                    imageSize.y = originalImageHeight * scale;
                }
                else {
                    imageSize = ImVec2(originalImageWidth, originalImageHeight);
                }

                ImVec2 imagePos((310.0f - imageSize.x) / 2, (178.0f - imageSize.y) / 2);
                ImGui::SetCursorPos(imagePos);
                ImGui::Image(previewID, imageSize);
                // Кнопка загрузки превью в правом нижнем углу области превью
                ImGui::SetCursorPos(ImVec2(310.0f - 24.0f - 4.0f, 178.0f - 24.0f - 4.0f)); // Позиция: правый нижний угол (24x24 кнопка + 4px отступ)
                ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(107, 194, 57, 0));
                if (ImGui::ImageButton(m_tFolder->surface_get(), ImVec2(24, 24))) {
                    xr_string fullPath = m_CurrentPath.empty() ? contextMenuItem : m_CurrentPath + "\\" + contextMenuItem;

                    // Открытие диалогового окна выбора файла
                    OPENFILENAMEA ofn;
                    char szFile[260] = "";
                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = nullptr;
                    ofn.lpstrFile = szFile;
                    ofn.nMaxFile = sizeof(szFile);
                    ofn.lpstrFilter = "PNG Files (*.png)\0*.png\0All Files (*.*)\0*.*\0";
                    ofn.nFilterIndex = 1;
                    ofn.lpstrFileTitle = nullptr;

                    if (GetOpenFileNameA(&ofn)) {
                        // Формирование пути для сохранения в папку previews
                        xr_string previewFileName = contextMenuItem;
                        size_t dotPos = previewFileName.find_last_of('.');
                        if (dotPos != xr_string::npos)
                            previewFileName = previewFileName.substr(0, dotPos);
                        xr_string previewPath = xr_string("previews\\") + previewFileName + ".png";
                        string_path targetPath;
                        FS.update_path(targetPath, "$objects$", previewPath.c_str());

                        // Копирование выбранного файла в папку previews
                        if (CopyFileA(szFile, targetPath, FALSE)) {
                            ELog.Msg(mtInformation, "Preview image copied to: %s", targetPath);

                            // Загрузка изображения в текстуру
                            D3DXIMAGE_INFO imageInfo;
                            if (SUCCEEDED(D3DXGetImageInfoFromFileA(targetPath, &imageInfo))) {
                                IDirect3DTexture9* pTex = nullptr;
                                HRESULT hr = D3DXCreateTextureFromFileExA(
                                    HW.pDevice,
                                    targetPath,
                                    imageInfo.Width,
                                    imageInfo.Height,
                                    1,
                                    0,
                                    D3DFMT_A8R8G8B8,
                                    D3DPOOL_MANAGED,
                                    D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER,
                                    D3DX_FILTER_BOX,
                                    0,
                                    nullptr,
                                    nullptr,
                                    &pTex
                                );
                                if (SUCCEEDED(hr) && pTex) {
                                    // Обновление кэша превью
                                    CachedTexture newCacheEntry;
                                    newCacheEntry.textureID = (ImTextureID)pTex;
                                    newCacheEntry.width = (float)imageInfo.Width;
                                    newCacheEntry.height = (float)imageInfo.Height;
                                    pTex->AddRef();

                                    // Сохранение в кэш
                                    std::lock_guard<std::mutex> lock(thumbnailMutex);
                                    m_PreviewCache[contextMenuItem] = newCacheEntry;
                                    m_CacheOrder.push_back(contextMenuItem);

                                    // Ограничение размера кэша
                                    if (m_CacheOrder.size() > 50) {
                                        auto oldest = m_CacheOrder.front();
                                        auto oldestIt = m_PreviewCache.find(oldest);
                                        if (oldestIt != m_PreviewCache.end()) {
                                            if (oldestIt->second.textureID && oldestIt->second.textureID != m_TextureNull->surface_get()) {
                                                ((IDirect3DTexture9*)oldestIt->second.textureID)->Release();
                                            }
                                            m_PreviewCache.erase(oldestIt);
                                        }
                                        m_CacheOrder.erase(m_CacheOrder.begin());
                                    }

                                    ELog.Msg(mtInformation, "Preview image loaded for item: %s from %s", contextMenuItem.c_str(), targetPath);
                                }
                                else {
                                    ELog.Msg(mtError, "Failed to load preview image from: %s", targetPath);
                                }
                            }
                            else {
                                ELog.Msg(mtError, "Failed to get image info for: %s", targetPath);
                            }
                        }
                        else {
                            ELog.Msg(mtError, "Failed to copy preview image to: %s", targetPath);
                        }
                    }
                    else {
                        ELog.Msg(mtInformation, "Preview image selection cancelled for item: %s", contextMenuItem.c_str());
                    }
                }
                if (ImGui::IsItemHovered()) ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

                ImGui::EndChild();
                ImGui::PopStyleColor(2);

                // ... (rest of your code for item name and buttons)


                ImGui::PushFont(g_FontRoboto2_24);
                ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 0.0f);
                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 16.0f);
                ImGui::Text("%s", contextMenuItem.c_str());
                ImGui::PopFont();
                ImGui::Separator();
                ImGui::SetCursorPosY(ImGui::GetCursorPosY() + -2.0f); //
                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 16.0f); //horizontal
                xr_string fullPath = m_CurrentPath.empty() ? item.name : m_CurrentPath + "\\" + item.name;
                if (item.isFolder) {
                    FS_FileSet lst;
                    int fileCount = 0;
                    if (Lib.GetObjects(lst)) {
                        for (const auto& file : lst) {
                            if (file.name.find(fullPath + "\\") == 0 && file.name != fullPath) {
                                fileCount++;
                            }
                        }
                    }
                    ImGui::Text("Files: %d", fileCount);
                }
                else {
                    CEditableObject* editObj = Lib.CreateEditObject(fullPath.c_str());
                    if (editObj) {
                        int vertexCount = 0;
                        int faceCount = 0;
                        for (auto& mesh : editObj->Meshes()) {
                            vertexCount += mesh->GetVertexCount();
                            faceCount += mesh->GetFaceCount();
                        }
                        ImGui::PushFont(g_FontHitmark);
                        ImGui::Text("Vertex Count: %d  | ", vertexCount);
                        ImGui::SameLine();
                        ImGui::Text("Face Count: %d", faceCount);
                        ImGui::PopFont();
                        Lib.RemoveEditObject(editObj);
                    }
                    else {
                        ImGui::Text("Vertex Count: N/A");
                        ImGui::SameLine();
                        ImGui::Text("Face Count: N/A");
                        
                    }
                }
                ImGui::Separator();


                // --- Кнопки Fav / Rename / Trash ---
                ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5.0f);
                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 16.0f);
                ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(107, 194, 57, 0));
                if (ImGui::ImageButton(m_tFavorite->surface_get(), ImVec2(20, 20))) {
                    // обработка favorite
                }
                ImGui::PopStyleColor();
                if (ImGui::IsItemHovered()) ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                
                ImGui::SameLine();
                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.0f);

                // Assuming this is the rename button (using m_tFavorite icon twice)
                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.0f);

                if (ImGui::ImageButton(m_tRename->surface_get(), ImVec2(20, 20))) {
                    xr_string fullPath = m_CurrentPath.empty() ? contextMenuItem : m_CurrentPath + "\\" + contextMenuItem;

                    // Открытие диалогового окна выбора файла
                    OPENFILENAMEA ofn;
                    char szFile[260] = "";
                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = nullptr;
                    ofn.lpstrFile = szFile;
                    ofn.nMaxFile = sizeof(szFile);
                    ofn.lpstrFilter = "PNG Files (*.png)\0*.png\0All Files (*.*)\0*.*\0";
                    ofn.nFilterIndex = 1;
                    ofn.lpstrFileTitle = nullptr;
                    ofn.nMaxFileTitle = 0;
                    ofn.lpstrInitialDir = nullptr;
                    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

                    if (GetOpenFileNameA(&ofn)) {
                        // Загрузка выбранного изображения
                        D3DXIMAGE_INFO imageInfo;
                        if (SUCCEEDED(D3DXGetImageInfoFromFileA(szFile, &imageInfo))) {
                            IDirect3DTexture9* pTex = nullptr;
                            HRESULT hr = D3DXCreateTextureFromFileExA(
                                HW.pDevice,
                                szFile,
                                imageInfo.Width,
                                imageInfo.Height,
                                1,
                                0,
                                D3DFMT_A8R8G8B8,
                                D3DPOOL_MANAGED,
                                D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER,
                                D3DX_FILTER_BOX,
                                0,
                                nullptr,
                                nullptr,
                                &pTex
                            );
                            if (SUCCEEDED(hr) && pTex) {
                                // Обновление кэша превью
                                CachedTexture newCacheEntry;
                                newCacheEntry.textureID = (ImTextureID)pTex;
                                newCacheEntry.width = (float)imageInfo.Width;
                                newCacheEntry.height = (float)imageInfo.Height;
                                pTex->AddRef();

                                // Сохранение в кэш
                                std::lock_guard<std::mutex> lock(thumbnailMutex);
                                m_PreviewCache[contextMenuItem] = newCacheEntry;
                                m_CacheOrder.push_back(contextMenuItem);

                                // Ограничение размера кэша
                                if (m_CacheOrder.size() > 50) {
                                    auto oldest = m_CacheOrder.front();
                                    auto oldestIt = m_PreviewCache.find(oldest);
                                    if (oldestIt != m_PreviewCache.end()) {
                                        if (oldestIt->second.textureID && oldestIt->second.textureID != m_TextureNull->surface_get()) {
                                            ((IDirect3DTexture9*)oldestIt->second.textureID)->Release();
                                        }
                                        m_PreviewCache.erase(oldestIt);
                                    }
                                    m_CacheOrder.erase(m_CacheOrder.begin());
                                }

                                ELog.Msg(mtInformation, "Preview image loaded for item: %s from %s", contextMenuItem.c_str(), szFile);
                            }
                            else {
                                ELog.Msg(mtError, "Failed to load preview image from: %s", szFile);
                            }
                        }
                        else {
                            ELog.Msg(mtError, "Failed to get image info for: %s", szFile);
                        }
                    }
                    else {
                        ELog.Msg(mtInformation, "Preview image selection cancelled for item: %s", contextMenuItem.c_str());
                    }
                }
                if (ImGui::IsItemHovered()) ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

                ImGui::SameLine();
                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.0f);
               
                if (ImGui::ImageButton(m_tTrashFolder->surface_get(), ImVec2(20, 20))) {
                    m_SelectedItem = contextMenuItem;
                    m_DeleteDialogOpen = true;
                    //DeleteItem(); // DeleteItem() should likely be called after a confirmation dialog, not directly here.
                    ImGui::CloseCurrentPopup();
                }
                
                if (ImGui::IsItemHovered()) ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

                // --- Попап переименования ---
                if (ImGui::BeginPopup("RenamePopup")) {
                    ImGui::SetWindowSize(ImVec2(200, 100));
                    ImGui::Text("Rename Item");
                    ImGui::Separator();
                    ImGui::SetKeyboardFocusHere(); // Фокус на поле ввода
                    if (ImGui::InputText("##rename_input", renameBuffer, sizeof(renameBuffer), ImGuiInputTextFlags_EnterReturnsTrue)) {
                        contextMenuItem = renameBuffer;
                        contextMenuTarget->name = renameBuffer; // Присваиваем новое имя объекту
                        ImGui::CloseCurrentPopup();
                    }
                    if (ImGui::Button("Cancel")) {
                        ImGui::CloseCurrentPopup();
                    }
                    ImGui::EndPopup();
                }

                ImGui::EndPopup();
            } 


            ImVec2 rectMin = ImGui::GetItemRectMin();
            ImVec2 rectMax = ImGui::GetItemRectMax();
            if (isSelected) {
                ImGui::GetWindowDrawList()->AddRectFilled(
                    rectMin, rectMax,
                    IM_COL32(131, 215, 255, 128), // Сплошной голубой фон при выделении
                    7.0f
                );
            }
            if (ImGui::IsItemHovered()) {
                ImGui::GetWindowDrawList()->AddRect(
                    rectMin, rectMax,
                    IM_COL32(131, 215, 255, 255), // Аутлайн голубого цвета при наведении
                    7.0f,
                    0,
                    2.0f // Толщина аутлайна 2 пикселя
                );
            }

            ImVec2 cur = rectMin;
            cur.x += (columnWidth - tileSize) / 2; // Скорректировать для отступа
            cur.y += 7.0f;
            ImGui::SetCursorScreenPos(cur);
            ImTextureID iconID = item.isFolder ? (item.name == "_trash" ? m_tTrashFolder->surface_get() : m_tFolder->surface_get()) : m_TextureNull->surface_get();
            if (!item.isFolder)
            {
                auto it = m_PreviewCache.find(item.name);
                if (it != m_PreviewCache.end())
                    iconID = it->second.textureID;
            }
            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 3.0f); // Сдвиг изображения на 3px вправо
            ImGui::Image(iconID, ImVec2(tileSize - 8, tileSize - 8)); // Размер картинки превью
            ImGui::SetCursorScreenPos(ImVec2(rectMin.x + (columnWidth - ImGui::CalcTextSize(item.name.c_str()).x) / 2, cur.y + tileSize + 2.0f));
            ImGui::TextWrapped("%s", item.name.c_str());
            ImGui::PopID();
            ImGui::EndGroup();

            columnIndex = (columnIndex + 1) % columns; // Переход к следующей колонке, сброс при заполнении строки
        }
        ImGui::EndTable();
    }
    ImGui::PopStyleVar();
    /// <summary>
    /// //////////////////////////////////////////////////////////////////////////////////////////////////////
    /// </summary>
    ImGui::EndChild();
    ImGui::Columns(1);
    if (m_Selection)
    {
        bool change = false;
        xr_string result;
        if (UIChooseForm::GetResult(change, result))
        {
            if (change)
            {
                xr_string candidate = NormalizeName(result);
                if (IsValidName(candidate)) {
                    xr_string fullCandidate = candidate;
                    if (!m_CurrentPath.empty() && fullCandidate.find(m_CurrentPath + "\\") != 0)
                        fullCandidate = m_CurrentPath + "\\" + fullCandidate;
                    m_PendingObject = fullCandidate;
                    ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
                    if (objTool && objTool->pForm)
                        if (UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm))
                            uiObjTool->SetCurrent(fullCandidate.c_str());
                }
            }
            m_Selection = false;
        }
        UIChooseForm::Update();
    }
    ImGui::PopStyleVar();

    if (!m_PendingObject.empty() && Tools->GetAction() == etaAdd && ImGui::IsMouseClicked(0))
    {
        xr_string fullCandidate;
        if (ResolveObjectFile(m_PendingObject, fullCandidate))
        {
            Fvector pos = { 0.f, 0.f, 0.f };
            if (GetMouseScenePosition(pos))
            {
                AddObjectToScene(fullCandidate, pos);
                ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
                if (objTool && objTool->pForm)
                {
                    UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm);
                    if (uiObjTool)
                        uiObjTool->SetCurrent(fullCandidate.c_str());
                }
            }
            else
            {
                ELog.DlgMsg(mtError, "Cannot get mouse position for scene placement.");
            }
        }
        else
        {
            ELog.DlgMsg(mtError, "Cannot place object, file does not exist or invalid: %s", m_PendingObject.c_str());
            m_PendingObject.clear();
        }
    }
    ImGui::PopStyleVar();

    m_AddButtonClicked = false;
    ImGui::End();
}

void UIContentBrowser::RenameItem(const xr_string& newName)
{
    if (m_SelectedItem.empty()) {
        ELog.DlgMsg(mtError, "No item selected for renaming.");
        return;
    }

    xr_string oldPath = m_CurrentPath;
    if (!oldPath.empty()) oldPath += "\\";
    oldPath += m_SelectedItem;
    xr_string newPath = m_CurrentPath;
    if (!newPath.empty()) newPath += "\\";
    newPath += newName;

    string_path oldPhysicalPath, newPhysicalPath;
    bool isFolder = false;

    xr_string normalizedOldPath = NormalizeName(oldPath);
    xr_string normalizedNewPath = NormalizeName(newPath);

    ELog.Msg(mtInformation, "RenameItem: Attempting to rename %s to %s", normalizedOldPath.c_str(), normalizedNewPath.c_str());

    if (FS.exist(oldPhysicalPath, "$fs_root$", (normalizedOldPath + "\\").c_str())) {
        isFolder = true;
        ELog.Msg(mtInformation, "RenameItem: Item %s is a folder in $fs_root$", normalizedOldPath.c_str());
    }
    else {
        xr_string resolvedOldPath;
        if (ResolveObjectFile(normalizedOldPath, resolvedOldPath)) {
            isFolder = false;
            normalizedOldPath = resolvedOldPath;
            ELog.Msg(mtInformation, "RenameItem: Resolved file path %s in $objects$", normalizedOldPath.c_str());
        }
        else {
            ELog.DlgMsg(mtError, "Item does not exist: %s (checked in $fs_root$ and $objects$)", normalizedOldPath.c_str());
            return;
        }
    }

    if (isFolder) {
        xr_string oldFullPath = FS.get_path("$fs_root$")->m_Path + normalizedOldPath;
        xr_string newFullPath = FS.get_path("$fs_root$")->m_Path + normalizedNewPath;
        if (FS.exist(newPhysicalPath, "$fs_root$", (normalizedNewPath + "\\").c_str())) {
            ELog.DlgMsg(mtError, "Folder already exists: %s", normalizedNewPath.c_str());
            return;
        }
        ELog.Msg(mtInformation, "RenameItem: Folder old path: %s, new path: %s", oldFullPath.c_str(), newFullPath.c_str());
        if (MoveFileA(oldFullPath.c_str(), newFullPath.c_str())) {
            m_SelectedItem = newName;
            RefreshList();
            ELog.Msg(mtInformation, "Folder renamed successfully: %s to %s", normalizedOldPath.c_str(), normalizedNewPath.c_str());
        }
        else {
            DWORD error = GetLastError();
            ELog.DlgMsg(mtError, "Failed to rename folder: %s to %s (Error code: %lu)", normalizedOldPath.c_str(), normalizedNewPath.c_str(), error);
        }
    }
    else {
        xr_string resolvedOldPath = normalizedOldPath;
        size_t dotPos = resolvedOldPath.find_last_of('.');
        xr_string extension = (dotPos != xr_string::npos) ? resolvedOldPath.substr(dotPos) : "";
        xr_string resolvedNewPath = newName;
        size_t newDotPos = newName.find_last_of('.');
        if (newDotPos == xr_string::npos || (newName.substr(newDotPos) != ".object" && newName.substr(newDotPos) != ".lwo")) {
            resolvedNewPath += extension;
            ELog.Msg(mtInformation, "RenameItem: Appended extension %s to new path: %s", extension.c_str(), resolvedNewPath.c_str());
        }
        newPath = m_CurrentPath;
        if (!newPath.empty()) newPath += "\\";
        newPath += resolvedNewPath;
        normalizedNewPath = NormalizeName(newPath);

        xr_string oldFullPath = FS.get_path("$objects$")->m_Path + normalizedOldPath;
        xr_string newFullPath = FS.get_path("$objects$")->m_Path + normalizedNewPath;
        if (FS.exist(newPhysicalPath, "$objects$", normalizedNewPath.c_str())) {
            ELog.DlgMsg(mtError, "File already exists: %s", normalizedNewPath.c_str());
            return;
        }

        xr_string oldFileName = normalizedOldPath;
        if (!m_CurrentPath.empty()) {
            size_t pos = normalizedOldPath.find(m_CurrentPath + "\\");
            if (pos == 0) {
                oldFileName = normalizedOldPath.substr(m_CurrentPath.length() + 1);
            }
        }
        xr_string newFileName = resolvedNewPath;
        if (!m_CurrentPath.empty()) {
            size_t pos = resolvedNewPath.find(m_CurrentPath + "\\");
            if (pos == 0) {
                newFileName = resolvedNewPath.substr(m_CurrentPath.length() + 1);
            }
        }
        xr_string oldBaseName = m_CurrentPath;
        if (!oldBaseName.empty()) oldBaseName += "\\";
        oldBaseName += oldFileName.substr(0, oldFileName.find_last_of('.'));
        xr_string newBaseName = m_CurrentPath;
        if (!newBaseName.empty()) newBaseName += "\\";
        newBaseName += newFileName.substr(0, newFileName.find_last_of('.'));
        xr_string oldThmPath = oldBaseName + ".thm";
        xr_string newThmPath = newBaseName + ".thm";
        xr_string oldThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(oldThmPath);
        xr_string newThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(newThmPath);
        bool thmRenamed = false;

        ELog.Msg(mtInformation, "RenameItem: Checking for thumbnail %s in $objects$", oldThmPath.c_str());
        if (FS.exist(oldPhysicalPath, "$objects$", oldThmPath.c_str())) {
            ELog.Msg(mtInformation, "RenameItem: Found thumbnail %s in $objects$", oldThmPath.c_str());
            if (FS.exist(newPhysicalPath, "$objects$", newThmPath.c_str())) {
                ELog.DlgMsg(mtError, "Thumbnail file already exists: %s", newThmPath.c_str());
                return;
            }
            ELog.Msg(mtInformation, "RenameItem: Attempting to rename thumbnail %s to %s", oldThmFullPath.c_str(), newThmFullPath.c_str());
            if (MoveFileA(oldThmFullPath.c_str(), newThmFullPath.c_str())) {
                thmRenamed = true;
                ELog.Msg(mtInformation, "Thumbnail renamed successfully: %s to %s", oldThmPath.c_str(), newThmPath.c_str());
            }
            else {
                DWORD error = GetLastError();
                ELog.DlgMsg(mtError, "Failed to rename thumbnail: %s to %s (Error code: %lu)", oldThmFullPath.c_str(), newThmFullPath.c_str(), error);
            }
        }
        else {
            ELog.Msg(mtInformation, "RenameItem: No thumbnail found for %s in $objects$", oldThmPath.c_str());
        }

        ELog.Msg(mtInformation, "RenameItem: Attempting to rename file %s to %s", oldFullPath.c_str(), newFullPath.c_str());
        if (MoveFileA(oldFullPath.c_str(), newFullPath.c_str())) {
            m_SelectedItem = resolvedNewPath;
            auto it = m_PreviewCache.find(resolvedOldPath);
            if (it != m_PreviewCache.end()) {
                m_PreviewCache.erase(it);
                auto cacheIt = std::find(m_CacheOrder.begin(), m_CacheOrder.end(), resolvedOldPath);
                if (cacheIt != m_CacheOrder.end()) {
                    m_CacheOrder.erase(cacheIt);
                }
            }
            if (thmRenamed) {
                LoadThumbnail(resolvedNewPath);
            }
            RefreshList();
            ELog.Msg(mtInformation, "File renamed successfully: %s to %s", normalizedOldPath.c_str(), normalizedNewPath.c_str());
        }
        else {
            DWORD error = GetLastError();
            ELog.DlgMsg(mtError, "Failed to rename file: %s to %s (Error code: %lu)", oldFullPath.c_str(), newFullPath.c_str(), error);
            if (thmRenamed) {
                ELog.Msg(mtInformation, "RenameItem: Attempting to revert thumbnail rename %s to %s", newThmFullPath.c_str(), oldThmFullPath.c_str());
                if (MoveFileA(newThmFullPath.c_str(), oldThmFullPath.c_str())) {
                    ELog.Msg(mtInformation, "Thumbnail rename reverted: %s back to %s", newThmPath.c_str(), oldThmPath.c_str());
                }
                else {
                    DWORD revertError = GetLastError();
                    ELog.DlgMsg(mtError, "Failed to revert thumbnail rename: %s to %s (Error code: %lu)", newThmFullPath.c_str(), oldThmFullPath.c_str(), revertError);
                }
            }
        }
    }
}

void UIContentBrowser::DeleteItem()
{
    if (m_SelectedItem.empty()) {
        ELog.DlgMsg(mtError, "No item selected for deletion.");
        return;
    }

    xr_string itemPath = m_CurrentPath;
    if (!itemPath.empty()) itemPath += "\\";
    itemPath += m_SelectedItem;

    xr_string normalizedPath = NormalizeName(itemPath);
    ELog.Msg(mtInformation, "DeleteItem: Attempting to delete %s", normalizedPath.c_str());

    xr_string trashPath = FS.get_path("$objects$")->m_Path + xr_string("_trash");
    CreateDirectoryA(trashPath.c_str(), NULL);
    ELog.Msg(mtInformation, "DeleteItem: Ensured _trash directory exists at %s", trashPath.c_str());

    string_path oldPhysicalPath;
    bool isFolder = false;

    if (FS.exist(oldPhysicalPath, "$fs_root$", (normalizedPath + "\\").c_str())) {
        isFolder = true;
        ELog.Msg(mtInformation, "DeleteItem: Item %s is a folder in $fs_root$", normalizedPath.c_str());
    }
    else {
        xr_string resolvedPath;
        if (ResolveObjectFile(normalizedPath, resolvedPath)) {
            isFolder = false;
            normalizedPath = resolvedPath;
            ELog.Msg(mtInformation, "DeleteItem: Resolved file path %s in $objects$", normalizedPath.c_str());
        }
        else {
            ELog.DlgMsg(mtError, "Item does not exist: %s (checked in $fs_root$ and $objects$)", normalizedPath.c_str());
            return;
        }
    }

    xr_string oldFullPath = (isFolder ? FS.get_path("$fs_root$") : FS.get_path("$objects$"))->m_Path + normalizedPath;
    xr_string trashDestPath = "_trash\\" + m_SelectedItem;
    if (isFolder) {
        trashDestPath += "\\";
    }
    else {
        size_t dotPos = normalizedPath.find_last_of('.');
        if (dotPos != xr_string::npos) {
            trashDestPath += normalizedPath.substr(dotPos);
        }
    }
    xr_string newFullPath = FS.get_path("$objects$")->m_Path + trashDestPath;

    if (FS.exist(oldPhysicalPath, isFolder ? "$fs_root$" : "$objects$", trashDestPath.c_str())) {
        ELog.DlgMsg(mtError, "Item already exists in trash: %s", trashDestPath.c_str());
        return;
    }

    ELog.Msg(mtInformation, "DeleteItem: Moving %s to %s", oldFullPath.c_str(), newFullPath.c_str());
    if (MoveFileA(oldFullPath.c_str(), newFullPath.c_str())) {
        ELog.Msg(mtInformation, "DeleteItem: Successfully moved %s to %s", normalizedPath.c_str(), trashDestPath.c_str());

        if (!isFolder) {
            xr_string oldFileName = normalizedPath;
            if (!m_CurrentPath.empty()) {
                size_t pos = normalizedPath.find(m_CurrentPath + "\\");
                if (pos == 0) {
                    oldFileName = normalizedPath.substr(m_CurrentPath.length() + 1);
                }
            }
            xr_string oldBaseName = m_CurrentPath;
            if (!oldBaseName.empty()) oldBaseName += "\\";
            oldBaseName += oldFileName.substr(0, oldFileName.find_last_of('.'));
            xr_string oldThmPath = oldBaseName + ".thm";
            xr_string newThmPath = "_trash\\" + m_SelectedItem.substr(0, m_SelectedItem.find_last_of('.')) + ".thm";
            xr_string oldThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(oldThmPath);
            xr_string newThmFullPath = FS.get_path("$objects$")->m_Path + NormalizeName(newThmPath);

            ELog.Msg(mtInformation, "DeleteItem: Checking for thumbnail %s in $objects$", oldThmPath.c_str());
            if (FS.exist(oldPhysicalPath, "$objects$", oldThmPath.c_str())) {
                ELog.Msg(mtInformation, "DeleteItem: Found thumbnail %s in $objects$", oldThmPath.c_str());
                if (FS.exist(oldPhysicalPath, "$objects$", newThmPath.c_str())) {
                    ELog.DlgMsg(mtError, "Thumbnail already exists in trash: %s", newThmPath.c_str());
                }
                else {
                    ELog.Msg(mtInformation, "DeleteItem: Moving thumbnail %s to %s", oldThmFullPath.c_str(), newThmFullPath.c_str());
                    if (MoveFileA(oldThmFullPath.c_str(), newThmFullPath.c_str())) {
                        ELog.Msg(mtInformation, "DeleteItem: Thumbnail moved successfully: %s to %s", oldThmPath.c_str(), newThmPath.c_str());
                    }
                    else {
                        DWORD error = GetLastError();
                        ELog.DlgMsg(mtError, "DeleteItem: Failed to move thumbnail: %s to %s (Error code: %lu)", oldThmFullPath.c_str(), newThmFullPath.c_str(), error);
                    }
                }
            }
            else {
                ELog.Msg(mtInformation, "DeleteItem: No thumbnail found for %s in $objects$", oldThmPath.c_str());
            }

            auto it = m_PreviewCache.end();
            it = m_PreviewCache.find(normalizedPath);
            if (it != m_PreviewCache.end()) {
                m_PreviewCache.erase(it);
                auto cacheIt = m_CacheOrder.end();
                cacheIt = std::find(m_CacheOrder.begin(), m_CacheOrder.end(), normalizedPath);
                if (cacheIt != m_CacheOrder.end()) {
                    m_CacheOrder.erase(cacheIt);
                }
            }
        }

        m_SelectedItem.clear();
        m_PendingObject.clear();
        RefreshList();
    }
    else {
        DWORD error = GetLastError();
        ELog.DlgMsg(mtError, "DeleteItem: Failed to move %s to %s (Error code: %lu)", oldFullPath.c_str(), newFullPath.c_str(), error);
    }
}
void UIContentBrowser::RefreshList()
{
    g_pSharedMemoryContainer->clean();
    if (m_RefreshInProgress)
        return;
    m_RefreshInProgress = true;
    m_Items.clear();
    ListItemsVec items;
    FS_FileSet lst;
    if (Lib.GetObjects(lst))
    {
        xr_string searchLower = m_SearchQuery;
        std::transform(searchLower.begin(), searchLower.end(), searchLower.begin(), [](char c) { return std::tolower(c); });

        for (const auto& file : lst)
        {
            xr_string relativeName = file.name;
            if (!m_CurrentPath.empty())
            {
                if (relativeName.find(m_CurrentPath + "\\") != 0)
                    continue;
                relativeName = relativeName.substr(m_CurrentPath.length() + 1);
            }
            xr_string relativeLower = relativeName;
            std::transform(relativeLower.begin(), relativeLower.end(), relativeLower.begin(), [](char c) { return std::tolower(c); });
            if (!m_SearchQuery.empty() && relativeLower.find(searchLower) == xr_string::npos)
                continue;
            size_t pos = relativeName.find('\\');
            Item item;
            item.isFolder = pos != xr_string::npos;
            item.name = item.isFolder ? relativeName.substr(0, pos) : relativeName;
            if (!IsValidName(item.name))
                continue;
            auto it = std::find_if(m_Items.begin(), m_Items.end(),
                [&item](const Item& i) { return i.name == item.name && i.isFolder == item.isFolder; });
            if (it == m_Items.end())
                m_Items.push_back(item);
        }
    }
    std::sort(m_Items.begin(), m_Items.end(),
        [](const Item& a, const Item& b) { return a.isFolder == b.isFolder ? a.name < b.name : a.isFolder > b.isFolder; });

    // Queue thumbnails for async loading
    {
        std::lock_guard<std::mutex> lock(thumbnailMutex);
        for (auto& item : m_Items)
            if (!item.isFolder && m_PreviewCache.find(item.name) == m_PreviewCache.end())
                thumbnailLoadQueue.push(item.name);
    }

    // Start thumbnail loading thread if not running
    if (!thumbnailThreadRunning)
    {
        thumbnailThreadRunning = true;
        std::thread([this]() {
            while (true)
            {
                xr_string name;
                {
                    std::lock_guard<std::mutex> lock(thumbnailMutex);
                    if (thumbnailLoadQueue.empty())
                    {
                        thumbnailThreadRunning = false;
                        break;
                    }
                    name = thumbnailLoadQueue.front();
                    thumbnailLoadQueue.pop();
                }
                LoadThumbnail(name);
            }
            }).detach();
    }

    m_ObjectList->AssignItems(items);
    BuildDirectoryTree();
    m_RefreshInProgress = false;
}

void UIContentBrowser::OnItemClicked(const xr_string& item, bool isFolder, const xr_string& itemPath)
{
    if (isFolder && !item.empty())
    {
        xr_string newPath = itemPath;
        FS_FileSet lst;
        if (Lib.GetObjects(lst))
        {
            bool pathExists = false;
            for (const auto& file : lst)
                if (file.name.find(newPath + "\\") == 0 || file.name == newPath)
                {
                    pathExists = true;
                    break;
                }
            if (pathExists)
            {
                m_PathHistory.push_back(m_CurrentPath);
                m_CurrentPath = newPath;
                m_SelectedItem.clear();
                m_PendingObject.clear();
                RefreshList();
            }
        }
    }
    else if (!isFolder && IsValidName(item))
    {
        m_SelectedItem = item;
        ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
        if (objTool && objTool->pForm)
            if (UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm)) {
                xr_string fullPath = m_CurrentPath;
                if (!fullPath.empty()) fullPath += "\\";
                fullPath += m_SelectedItem;
                uiObjTool->SetCurrent(fullPath.c_str());
                m_PendingObject = fullPath;
            }
    }
}

void UIContentBrowser::LoadThumbnail(const xr_string& name)
{
    // Check cache first to avoid reloading
    {
        std::lock_guard<std::mutex> lock(thumbnailMutex);
        if (m_PreviewCache.find(name) != m_PreviewCache.end())
            return;
    }

    ImTextureID imgID = nullptr;
    float width = 0.0f;
    float height = 0.0f;

    // Try loading PNG from previews folder
    xr_string textureName = name;
    size_t dotPos = textureName.find_last_of('.');
    if (dotPos != xr_string::npos)
        textureName = textureName.substr(0, dotPos);

    xr_string previewPath = "previews\\" + (m_CurrentPath.empty() ? "" : m_CurrentPath + "\\") + textureName + ".png";
    string_path physicalPath;
    if (FS.exist(physicalPath, "$objects$", previewPath.c_str()))
    {
        D3DXIMAGE_INFO imageInfo;
        if (SUCCEEDED(D3DXGetImageInfoFromFileA(physicalPath, &imageInfo)))
        {
            IDirect3DTexture9* pTex = nullptr;
            HRESULT hr = D3DXCreateTextureFromFileExA(
                HW.pDevice,
                physicalPath,
                imageInfo.Width,
                imageInfo.Height,
                1,
                0,
                D3DFMT_A8R8G8B8,
                D3DPOOL_MANAGED,
                D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER,
                D3DX_FILTER_BOX,
                0,
                nullptr,
                nullptr,
                &pTex
            );
            if (SUCCEEDED(hr) && pTex)
            {
                imgID = (ImTextureID)pTex;
                width = (float)imageInfo.Width;
                height = (float)imageInfo.Height;
                pTex->AddRef();
                ELog.Msg(mtInformation, "LoadThumbnail: Loaded preview PNG: %s at %fx%f", physicalPath, width, height);
            }
            else
            {
                ELog.DlgMsg(mtError, "LoadThumbnail: Failed to load preview PNG: %s", physicalPath);
            }
        }
    }

    // Fallback to existing logic if PNG not found
    if (!imgID)
    {
        SChooseEvents* e = UIChooseForm::GetEvents(smObject);
        if (e && !e->on_get_texture.empty())
        {
            xr_string fullPath = m_CurrentPath;
            if (!fullPath.empty())
                fullPath += "\\";
            fullPath += name;
            e->on_get_texture(fullPath.c_str(), imgID);

            // Assume dimensions for this case as they are not available from the callback.
            width = 128.0f;
            height = 128.0f;
        }
    }

    // If still no image, try .thm, .dds, or .tga
    if (!imgID)
    {
        ref_texture tex;
        xr_string basePath = m_CurrentPath;
        if (!basePath.empty())
            basePath += "\\";
        basePath += textureName;
        xr_string thmPath = basePath + ".thm";
        xr_string ddsPath = basePath + ".dds";
        xr_string tgaPath = basePath + ".tga";

        if (FS.exist(physicalPath, "$objects$", thmPath.c_str()))
        {
            EImageThumbnail* thm = ImageLib.CreateThumbnail(basePath.c_str(), EImageThumbnail::ETObject);
            if (thm)
            {
                thm->Update(imgID);
                // Use a standard size for thumbnails since Width() and Height() are not members
                width = 223.0f;
                height = 128.0f;
                xr_delete(thm);
            }
        }
        else if (FS.exist(physicalPath, "$game_textures$", ddsPath.c_str()))
        {
            tex.create(ddsPath.c_str());
            imgID = tex->surface_get();
            width = (float)tex->get_Width();
            height = (float)tex->get_Height();
        }
        else if (FS.exist(physicalPath, "$game_textures$", tgaPath.c_str()))
        {
            tex.create(tgaPath.c_str());
            imgID = tex->surface_get();
            width = (float)tex->get_Width();
            height = (float)tex->get_Height();
        }
    }

    // Store the new texture and its dimensions in the cache
    if (imgID)
    {
        std::lock_guard<std::mutex> lock(thumbnailMutex);
        CachedTexture newCacheEntry;
        newCacheEntry.textureID = imgID;
        newCacheEntry.width = width;
        newCacheEntry.height = height;

        m_PreviewCache[name] = newCacheEntry;
        m_CacheOrder.push_back(name);

        if (m_CacheOrder.size() > 150)
        {
            auto oldest = m_CacheOrder.front();
            auto oldestIt = m_PreviewCache.find(oldest);
            if (oldestIt != m_PreviewCache.end())
            {
                if (oldestIt->second.textureID && oldestIt->second.textureID != m_TextureNull->surface_get())
                {
                    ((IDirect3DTexture9*)oldestIt->second.textureID)->Release();
                }
                m_PreviewCache.erase(oldestIt);
            }
            m_CacheOrder.erase(m_CacheOrder.begin());
        }
    }
}

// Rest of the existing code remains unchanged...


void UIContentBrowser::AddObjectToScene(const xr_string& itemName, const Fvector& pos)
{
    g_pSharedMemoryContainer->clean();
    if (itemName.empty()) {
        ELog.Msg(mtInformation, "AddObjectToScene: Empty itemName");
        return;
    }

    xr_string relativePath;
    if (!ResolveObjectFile(itemName, relativePath)) {
        relativePath = NormalizeName(itemName);
        ELog.Msg(mtInformation, "AddObjectToScene: Invalid path: %s", relativePath.c_str());
        return;
    }

    string_path physicalPath;
    if (!FS.exist(physicalPath, "$objects$", relativePath.c_str())) {
        ELog.Msg(mtInformation, "AddObjectToScene: File not found: %s", relativePath.c_str());
        ELog.DlgMsg(mtError, "Object file does not exist: %s", relativePath.c_str());
        return;
    }

    xr_string objectName = relativePath;
    size_t dotPos = objectName.find_last_of('.');
    if (dotPos != xr_string::npos)
        objectName = objectName.substr(0, dotPos);

    string256 namebuffer;
    Scene->GenObjectName(OBJCLASS_SCENEOBJECT, namebuffer, objectName.c_str());

    CSceneObject* obj = xr_new<CSceneObject>((LPVOID)0, namebuffer);
    CEditableObject* ref = obj->SetReference(relativePath.c_str());
    if (!ref) {
        ELog.Msg(mtInformation, "AddObjectToScene: Failed to load: %s", relativePath.c_str());
        xr_delete(obj);
        ELog.DlgMsg(mtError, "Failed to load object: %s", relativePath.c_str());
        return;
    }

    Fvector up = { 0.f, 1.f, 0.f };
    obj->MoveTo(pos, up);
    Scene->AppendObject(obj);
    Scene->SelectObjects(false, OBJCLASS_SCENEOBJECT);
    obj->Select(true);

    ELog.Msg(mtInformation, "AddObjectToScene: Added: %s", namebuffer);

    ESceneObjectTool* objTool = dynamic_cast<ESceneObjectTool*>(Scene->GetTool(OBJCLASS_SCENEOBJECT));
    if (objTool && objTool->pForm) {
        UIObjectTool* uiObjTool = dynamic_cast<UIObjectTool*>(objTool->pForm);
        if (uiObjTool)
            uiObjTool->SetCurrent(relativePath.c_str());
    }
}

bool UIContentBrowser::GetMouseScenePosition(Fvector& pos)
{
    Ivector2 mousePos = UI->GetRenderMousePosition();
    Fvector start, dir;
    EDevice->m_Camera.MouseRayFromPoint(start, dir, mousePos);
    float dist = 1000.f;
    Fvector hit;
    if (Scene->RayPick(start, dir, dist, &hit, nullptr)) {
        pos = hit;
        return true;
    }
    return false;
} void UIContentBrowser::ClickOpenRawData()
{
    string_path RawDataPath;
    FS.update_path(RawDataPath, "$server_data_root$", "");
    ShellExecuteA(NULL, "open", RawDataPath, NULL, NULL, SW_SHOWDEFAULT);
}
